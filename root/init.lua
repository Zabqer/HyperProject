--HyperKernel by Zabqer. This code is autogenerated by build-kernel utility
local _K=setmetatable({},{__index=_G})_K.GLOBAL=_G;_ENV=_K;_K._K=_K;

--[[
______  __                           _______________
___  / / /____  _______________________  __ \_  ___/
__  /_/ /__  / / /__  __ \  _ \_  ___/  / / /____ \ 
_  __  / _  /_/ /__  /_/ /  __/  /   / /_/ /____/ / 
/_/ /_/  _\__, / _  .___/\___//_/    \____/ /____/  
         /____/  /_/                                
                      Maded by Zabqer with love
]]--

KernelVersion = "0.0.0.1"

GLOBAL._OSVERSION = "HyperKernel " .. KernelVersion

function panic(str)
	kernelLog(Log.ERROR, "Kernel panic: " .. str)
	while true do computer.pullSignal(1) end
end



;

Config = {
	roofs="filesystem_address"
}
;

local UserSpace = Config.disableUserSpace and GLOBAL or setmetatable({}, {__index = GLOBAL})

function nullFunction() end

function protectObject(object, methods, name)
		return setmetatable({}, {
				__metatable = name or "Object",
				__index = function (_, key)
						return methods[key] and function(_, ...)
								return methods[key](object, ...)
						end
				end,
				__newindex = nullFunction,
				__tostring = methods.string and function ()
						return methods.string(object)
				end,
				__len = methods.len and function ()
						return methods.len(object)
				end,
				__pairs = methods.pairs and function ()
					return methods.pairs(object)
				end
		})
end

function protectTable(table, read, write)
		return setmetatable({}, {
				__metatable = "ProtectedTable",
				__index = read and table or nullFunction,
				__newindex = write and table or nullFunction
		})
end

function GLOBAL.yield()
		thisThread.deadline = computer.uptime()
		coroutine.yield()
end

GLOBAL.os = setmetatable({}, {__index = os})

function GLOBAL.os.getenv(key)
		checkArg(1, key, "string")
		return thisThread.process.envvar[key]
end

function GLOBAL.os.setenv(key, value)
		checkArg(1, key, "string")
		checkArg(2, value, "string", "nil")
		thisThread.process.envvar[key] = value
end

function GLOBAL.os.sleep(time)
		checkArg(1, time, "number", "nil")
		thisThread.deadline = computer.uptime() + (time or 0)
		coroutine.yield()
end

local rtype = type
function GLOBAL.type(value)
		local mt = getmetatable(value)
		if rtype(mt) == "string" then
				return mt
		end
		return rtype(value)
end

local rload = load
function GLOBAL.load(chunk, name, mode, env)
		yield()
		return rload(chunk, name, mode, env or setmetatable({}, {__index=UserSpace}))
end

function GLOBAL.loadfile(path, mode, env)
		local file, reason = io.open(path, "r")
		if not file then
				return nil, reason
		end
		local chunk, reason = file:read("*a")
		file:close()
		if not chunk then
				return nil, reason
		end
		return load(chunk, "=" .. path, mode, env)
end

function GLOBAL.dofile(path)
  local f, reason = loadfile(path)
  if not f then
    return error(reason, 0)
  end
  return f()
end

function GLOBAL.print(...)
		local args = table.pack(...)
		for i = 1, #args do
				args[i] = tostring(args[i])
		end
		local string = table.concat(args, "\t")
		io.write(string, "\n")
end

local libcomputer = {
		pushSignal = function (name, ...)
				return computer.pushSignal(name, ...)
		end,
		pullSignal = function (timeout)
				checkArg(1, timeout, "number", "nil")
				thisThread.deadline = computer.uptime() + (timeout or math.huge)
				return coroutine.yield("signal")
		end,
		shutdown = computer.shutdown
}

local libcomponent = {
		list = component.list,
		type = component.type,
		invoke = component.invoke
}

local libunicode = {
		char = unicode.char,
		len = unicode.len,
		sub = unicode.sub
}

libs = {
		computer = libcomputer,
		component = libcomponent,
		unicode = libunicode
}

local package = {
		preload = libs,
		loading = {},
		loaded = setmetatable({}, {__mode = "v"}),
		searchers = {}
}

function package.searchpath(name, path, sep, rep)
		checkArg(1, name, "string")
		checkArg(2, path, "string")
		sep = sep or '.'
		rep = rep or '/'
		sep, rep = '%' .. sep, rep
		name = string.gsub(name, sep, rep)
		local errors = {}
		for subPath in string.gmatch(path, "([^;]+)") do
				subPath = string.gsub(subPath, "?", name)
				if filesystem.exists(subPath) then
						local file = io.open(subPath, "r")
 						if file then
 								file:close()
 								return subPath
 						end
 				end
 				table.insert(errors, "\tno file '" .. subPath .. "'")
		end
		return nil, table.concat(errors, "\n")
end

table.insert(package.searchers, function(name)
		return package.preload[name]
end)

table.insert(package.searchers, function(name)
		local path, reason = package.searchpath(name, "/lib/?.lua")--os.getenv("LIBPATH"))
		if path then
				local f
				f, reason = loadfile(path)
				if f then
        	local success
						success, reason = pcall(f)
						if success then
								return reason
     			end
				end
		end
		return nil, reason
end)

function GLOBAL.require(name)
		checkArg(1, name, "string")
		::start::
		if package.loaded[name] then
				return package.loaded[name]
		end
		if package.loading[name] then
				waitEvent("package_loaded", name)
				goto start
		end
		package.loading[name] = true
		local reason
		for _, searcher in pairs(package.searchers) do
				local success, lib
				success, lib, reason = pcall(searcher, name)
				if success and lib then
						package.loaded[name] = lib
						package.loading[name] = nil
						pushEvent("package_loaded", name)
						return lib
				elseif not success and lib then
						reason = lib
				end
		end
		package.loading[name] = nil
		error(string.format("Could not load module '%s': %s", name, reason or "module returned nil"))
end
;

kernelThread = {
	name = "kernel",
	deadline = 0,
}

thisThread = kernelThread

local nextPID, nextUID = 1, 1

function allocateIds()
	local pid, uid = nextPID, nextUID
	nextUID = nextUID + 1
	repeat
		nextPID = nextPID + 1
	until not threads[nextPID]
	return pid, uid
end

threads = {}
processes = {}

function createProcess(f, name, parent, user, paused, ...)
	local process = {
		name = name,
		processes = {},
		threads = {},
		parent = parent,
		user = user,
		workingDirectory = "/",
		envvar = parent and setmetatable({}, {__index=parent.envvar}) or {}
	}
	if parent then
		table.insert(parent.processes, process)
	end
	local th, reason = createThread(f, name, process, paused, ...)
	if not th then
		return nil, reason
	end
	process.pid = process.thread.pid
	process.uid = process.thread.uid
	processes[process.pid] = process
	kernelLog(Log.DEBUG, "Created process pid:", process.pid, "name:", process.name)
	return process
end

function createThread(f, name, process, paused, ...)
	local thread = {
		name = name or "unknown",
		running = false,
		paused = paused or false,
		process = process,
		deadline = computer.uptime(),
		eventQueue = {{"args", ...}},
		awaiting = "args"
	}
	thread.coroutine = coroutine.create(function (...)
		local args = table.pack(...)
		local result = table.pack(xpcall(function()
			f(table.unpack(args))
		end, function(msg)
			msg = msg or "unknown"
			kernelLog(Log.INFO, "Error in thread [pid: " .. thread.pid .. "]: " .. msg)
			kernelLog(Log.INFO, debug.traceback())
			if thread.process.stderr then
					thread.process.stderr:write("Error in thread [pid: " .. thread.pid .. "]: " .. msg .. "\n")
					thread.process.stderr:write(debug.traceback() .. "\n")
			end
		end))
		return table.unpack(result, 2)
	end)
	if not process.thread then
		process.thread = thread
	else
		table.insert(process.threads, thread)
	end
	thread.pid, thread.uid = allocateIds()
	threads[thread.pid] = thread
	kernelLog(Log.DEBUG, "Created thread pid:", thread.pid, "name:", thread.name, "run:", not paused)
	return thread
end

function kill(pid)
	local thread = threads[pid]
 	kernelLog(Log.DEBUG, "Killed", thread.process.thread == thread and "process" or "thread", "pid:", thread.pid, "name:", thread.name)
	if thread.process.thread == thread then
		for _, th in pairs(thread.process.threads) do
			kill(th.pid)
		end
		for _, p in pairs(thread.process.processes) do
			kill(th.pid)
		end
		processes[pid] = nil
		local index
		for i, p in pairs(thread.process.parent.processes) do
			if p.pid == pid then
				index = i
			end
		end
		table.remove(thread.process.parent.processes, index)
	else
		local index
		for i, th in pairs(thread.process.threads) do
			if th.pid == pid then
				index = i
			end
		end
		table.remove(thread.process.threads, index)
	end
	if pid < nextPID then
		nextPID = pid
	end
	pushEvent("kill", pid)
	threads[pid] = nil
end

function pushEvent(name, ...)
	for _, thread in pairs(threads) do
		if thread.awaiting == name then
			table.insert(thread.eventQueue, table.pack(name, ...))
		end
	end
end

function waitEvent(name, ...)
	local args
	while true do
		::wait::
		args = table.pack(coroutine.yield(name))
		for i, arg in ipairs(table.pack(...)) do
			if arg ~= nil and arg ~= args[i] then
				goto wait
			end
		end
		return name, table.unpack(args)
	end
end

local eventHandlers = {}

function addKenrelEventHandler(data, callback)
	kernelLog(Log.DEBUG, "Registered kernel event handler for", table.unpack(data))
	table.insert(eventHandlers, {
		data = data,
		callback = callback
	})
end

local libthread = {}

processMethods = {}
local iosMethods = {}

function processMethods:info()
	local childs = {}
	for _, th in pairs(self.process.threads) do
		table.insert(childs, th.pid)
	end
	for _, p in pairs(self.process.processes) do
		table.insert(childs, p.pid)
	end
	return protectTable({
		pid = self.process.pid,
		name = self.process.name,
		user = self.process.user,
		childs = childs,
		process = true
	}, true, false)
end

function processMethods:IO()
	return setmetatable({}, {
		__index = function (_, key)
			if key == "stdout" then
				return self.process.stdout
			elseif key == "stdin" then
				return self.process.stdin
			elseif key == "stderr" then
				return self.process.stderr
			end
			return nil
		end,
		__newindex = function (_, key, value)
			if type(value) ~= "Stream" then
				error("Not a stream")
				return
			end
			if key == "stdout" then
				self.process.stdout = value
			elseif key == "stdin" then
				self.process.stdin = value
			elseif key == "stderr" then
				self.process.stderr = value
			end
		end
	})
end

function processMethods:run()
	kernelLog(Log.DEBUG, "Process run pid:", self.process.pid, "name:", self.process.name)
	self.process.thread.paused = false
	for _, th in pairs(self.process.threads) do
		th.paused = false
	end
end

function processMethods:join()
	waitEvent("kill", self.process.pid)
end

local threadMethods = {}

function threadMethods:info()
	return protectTable({
		pid = self.thread.pid,
		name = self.thread.name,
		process = false
	}, true, false)
end

function libthread.createProcess(f, name, ...)
	checkArg(1, f, "string", "function")
	if type(f) == "string" then
		name = name or f
		local reason
		f, reason = loadfile(f)
		if not f then
			return nil, reason
		end
	end
	local process = createProcess(f, name, thisThread.process, thisThread.process.user, true, ...)
	return protectObject({
		process = process
	}, processMethods, "Process")
end

function libthread.thisProcess()
	return protectObject({
		process = thisThread.process
	}, processMethods, "Process")
end

function libthread.createThread(f, name, ...)
	checkArg(1, f, "function")
	local th = createThread(f, name, thisThread.process, false, ...)
end

function libthread.byPid(pid)
	checkArg(1, pid, "number")
	if processes[pid] then
		return protectObject({
			process = processes[pid]
		}, processMethods, "Process")
	end
	if threads[pid] then
		return protectObject({
			thread = threads[pid]
		}, threadMethods, "Thread")
	end
	return nil, "no such process"
end

libs.thread = libthread
;

Log = {
		DEBUG = 0,
		INFO = 1,
		WARNING = 2,
		ERROR = 3
}

local levelName = {
		[0] = "DEBUG",
		[1] = "INFO",
		[2] = "WARNING",
		[3] = "ERROR"
}

local function extend(level, ...)
		local str = ""
		for _, s in pairs({...}) do
				str = str .. " " .. s
		end
		local clock = math.floor(os.clock() * 1000) / 1000
		return "[" .. clock .. "] [" .. levelName[level] .. "]" .. str
end

kernelLogger = {
	write = function (_, str)
 		-- TODO write to file after boot
		bootLogger(str)
	end
}

function kernelLog(level, ...)
		local args = table.pack(...)
		for i = 1, #args do
				args[i] = tostring(args[i])
		end
		if level < 1 then
--			return
		end
		kernelLogger:write(extend(level, table.unpack(args)))
end

local gpu, screen = component.list("gpu")(), component.list("screen")()

local invoke = component.invoke

function bootLogger() end

if gpu and screen then
		invoke(gpu, "bind", screen)
		local w, h = invoke(gpu, "getResolution")
		local y = 0
		invoke(gpu, "fill", 1, 1, w, h, " ")
		local function drawLine(str)
				if y == h then
						invoke(gpu, "copy", 1, 2, w, h - 1, 0, -1)
						invoke(gpu, "fill", 1, h, w, 1, " ")
				else
						y = y + 1
				end
				invoke(gpu, "set", 1, y, str)
		end
		function bootLogger(str)
			str = str:gsub("\t", "  ")
			if dprint then
                        	dprint(str)
			end
			if true then
				return
			end
                            local ss = ""
                            for s in str:gmatch("[^\r\n]+") do
                                    ss = ss .. s
                                    while #ss > 0 do
					if unicode.len(ss) > w then
						line = unicode.wtrunc(ss, w)
                                        else
                                        	line = ss
                                        end
                                        drawLine(line)
                                        ss = unicode.sub(ss, unicode.len(line) + 1)
                                   end
                           end
		end
end
;

local drivers = {}

addKenrelEventHandler({"signal", "component_added"}, function (...)
	dprint("COMPONENT ADDED!", ...)
end)

function register_driver(type, add_callback, remove_callback)
	kernelLog(Log.DEBUG, "Register driver for", type)
end
;

local rootNode = {name="", nodes={}}

filesystem = {}

local function segmentate(path)
		local segments = {}
		for segment in path:gmatch("[^/]+") do
				if segment == ".." then
						table.remove(parts)
				elseif segment ~= "." then
						table.insert(segments, segment)
				end
		end
		return segments, path:sub(1, 1) == "/"
end

PathMethods = {}

function PathMethods:len()
		return #self.segments
end

function PathMethods:string()
		return (self.absolute and "/" or "") .. table.concat(self.segments, "/")
end

function PathMethods:absolute()
	return (self.absolute and "/" or thisThread.process.workingDirectory) .. table.concat(self.segments, "/")
end

function PathMethods:filename()
	return self.segments[#self.segments]
end

function PathMethods:append(path, index)
		checkArg(1, path, "string")
		checkArg(2, index, "number", "nil")
		index = index or #self.segments
		if index >= 0 and index <= #self.segments then
				local segments = segmentate(path)
				for i, segment in pairs(segments) do
						table.insert(self.segments, index + i, segment)
				end
				return true
		end
		return false
end

function PathMethods:remove(index)
		checkArg(1, index, "number", "nil")
		index = index or #self.segments
		if index > 0 and index <= #self.segments then
				return table.remove(self.segments, index)
		end
end

function PathMethods:pairs()
	return pairs(self.segments)
end

function PathMethods:at(index)
	checkArg(1, index, "number")
	if index > 0 and index <= #self.segments then
		return self.segments[index]
	end
end

local function Path(path)
		local obj = {}
		obj.segments, obj.absolute = segmentate(path)
		return protectObject(obj, PathMethods, "FilesystemPath")
end

local function getNode(path)
	-- Maybe rewrite?
	path = type(path) == "string" and Path(path) or path
	local outerpath = Path("")
	local node = rootNode
	while true do
		local nextNodeName = path:at(1)
		if not nextNodeName then
			return node, outerpath
		end
		local nextNode
		for _, n in pairs(node.nodes) do
			if n.name == nextNodeName then
				nextNode = n
			end
		end
		if not nextNode then
			for _, f in pairs(path) do
				outerpath:append(f)
			end
			return node, outerpath
		end
		node = nextNode
		outerpath:append(path:remove(1), 1)
	end
end

local function printNodes(node, i)
	i = i or 0
	dprint(string.rep(" ", i) .. ">" .. (node.name == "" and "/" or node.name) .. "<")
	for _, n in pairs(node.nodes) do
		printNodes(n, i + 1)
	end
end

local function createNode(node, path)
	for _, f in pairs(path) do
		local n = {name = f, nodes={}}
		table.insert(node.nodes, n)
		node = n
	end
	return node
end

-- local function getFilesystem(path)
-- 		local fspath = Path("")
-- 		path = Path(path)
-- 		dprint(path.absolute())
-- 		local node = nodes
-- 		function findNode(nodes, name)
-- 			for _, node in pairs(nodes) do
-- 				if node.name == name then
-- 					return node
-- 				end
-- 			end
-- 			return nil
-- 		end
-- 		local node = rootNode
-- 		while true do
-- 			local name = path:remove(1)
-- 			fspath:append(name)
-- 			local nnode = findNode(node.nodes, name)
-- 			if not nnode then
-- 				return node.driver, fspath.absolute()
-- 			end
-- 			node = nnode
-- 		end
-- 		-- while true do
-- 		-- 		if mounts[path.absolute()] then
-- 		-- 				return mounts[path.absolute()].driver, fspath.absolute()
-- 		-- 		end
-- 		-- 		if #path == 0 then
-- 		-- 				return nil, "no mounted filesystems"
-- 		-- 		end
-- 		-- 		fspath:append(path:remove(), 0)
-- 		-- end
-- end

local filesystemHandle = {}

function filesystemHandle:read(count)
		checkArg(2, count, "number")
		return self.driver.read(self.handle, count)
end

function filesystemHandle:close()
		return self.driver.close(self.handle)
end

function filesystem.mount(path, proxy)
		checkArg(1, path, "string")
		checkArg(2, proxy, "string", "table")
		path = Path(path)
		local node, fspath = getNode(path)
		if #fspath == 0 and node.drive then
				return false, "another file system mounted here"
		end
		node = createNode(node, path)
		node.driver = type(proxy) == "table" and proxy or component.proxy(proxy)
		-- push string to filesystem component, but to own drivers we push Path
		node.kernel_driver = type(proxy) == "table"
		kernelLog(Log.INFO, "Filesystem", proxy, "mounted at", path.string())
		return true
end

function filesystem.exists(path)
		checkArg(1, path, "string")
		local node, fspath = getNode(path)
		if not node then
			return false
		end
		return node.driver.exists(node.kernel_driver and fspath or fspath.string())
end

function filesystem.isDirectory(path)
		checkArg(1, path, "string")
		local node, fspath = getNode(path)
		if not node then
				return false
		end
		return node.driver.isDirectory(node.kernel_driver and fspath or fspath.string())
end


function filesystem.list(path)
		checkArg(1, path, "string")
		local node, fspath = getNode(path)
                if not node then
			return false
		end
		local files = {}
		if #fspath == 0 then
			for _, n in pairs(node.nodes) do
				table.insert(files, n.name)
			end
		end

        	local fsfiles = node.driver.list(node.kernel_driver and fspath or fspath.string())
		if fsfiles then
			for _, f in pairs(fsfiles) do
				table.insert(files, f)
			end
		end
		return files
end

function filesystem.open(path, mode)
		checkArg(1, path, "string")
		mode = mode or "r"
		checkArg(2, mode, "string")
		assert(({r=true, rb=true, w=true, wb=true, a=true, ab=true})[mode], "bad argument #2 (r[b], w[b] or a[b] expected, got " .. mode .. ")")
		local node, fspath = getNode(path)
		if not node then
				return nil, path
		end
		if ({r=true,rb=true})[mode] and not node.driver.exists(node.kernel_driver and fspath or fspath.string()) then
				return nil, "file not found: " .. fspath.string()
		end
		local handle, reason = node.driver.open(node.kernel_driver and fspath or fspath.string(), mode)
		if not handle then
				return nil, reason
		end
		local stream = {
				kernel_driver = node.kernel_driver,
				driver = node.driver,
				handle = handle
		}
		-- TODO protect
		return setmetatable(stream, {__index = filesystemHandle})
end

libs.filesystem = filesystem
;

function cb_added(uuid)
	return {
		write = function (handle, data)
			dprint("component.invoke", handle.uuid, "say", data)
			--component.invoke(handle.uuid, "")
		end
		-- TODO read by handling event
	}
end

function cb_removed(uuid)
	
end

register_driver("chat_box", cb_added, cb_removed)
;

function createAllocator()
	local list = {}
	local allocator = {
		list = list,
		index = 1
	}
	function allocator:new()
		local element = {}
		local index = self.index
		self.list[index] = element
		repeat
			self.index = self.index + 1
		until not self.list[self.index]
		element.index = index
		return element
	end
	function allocator:remove(element)
		panic("ALLOCATOR REMOVE")
	end
	return allocator, list
end
;

devfs = {
	label = "devfs",
	data = {}
}

local allocator, handles = createAllocator()

local function getNode(path)
	local node = devfs.data
	for _, n in pairs(path) do
		if node.__file then
			return nil, "file is not directory"
		end
		node = node[n]
		if not node then
			return nil, "no such file or directory"
		end
	end
	return node
end

function devfs.open(path)
	local node, reason = getNode(path)
	if not node.__file then
		return nil, "it's a directory"
	end
	local handle = allocator:new()
	handle.node = node
	if handle.open then
		handle.open(handle)
	end
	return handle.index
end

function devfs.read(index, ...)
	return handles[index].node.read(handles[index], ...)
end

function devfs.exists(path)
	local node = getNode(path)
	return not not node
end

function devfs.list(path)
	local node, result = getNode(path)
	if not node then
		return nil, result
	end
	if node.__file then
		return nil, "file is not directory"
	end
	local files = {}
	for n in pairs(node) do
		table.insert(files, n)
	end
	return files
end

function devfs.isDirectory(path)
	local node, result = getNode(path)
	if not node then
		return false
	end
	return not node.__file
end

devfs.data.null = {
	__file = true,
	write = function() end,
	read = function() end
}

;

local bufferMethods = {}

function bufferMethods:close()
		if self.w or self.a then
				bufferMethods.flush(self)
		end
		self.closed = true
		return self.stream:close()
end

function bufferMethods:flush()
		if #self.bufferWrite > 0 then
				local data = self.bufferWrite
				local result, reason = self.stream:write(data)
				if result then
						self.bufferWrite = ""
				else
						if reason then
								return nil, reason
						else
								return nil, "bad file descriptor"
						end
				end
		end
		return true
end

local function readChunk(self)
		local result, reason = self.stream:read(math.max(1,	self.bufferSize))
		if result then
				self.bufferRead = self.bufferRead .. result
				return self
		else
				return nil, reason
		end
end

function readBytesOrChars(self, n)
		n = math.max(n, 0)
		local len, sub
		if self.b then
				len = rawlen
				sub = string.sub
		else
				len = unicode.len
				sub = unicode.sub
		end
		local data = ""
		repeat
				if len(self.bufferRead) == 0 then
						local result, reason = readChunk(self)
						if not result then
								if reason then
										return nil, reason
								else
										return #data > 0 and data or nil
								end
						end
				end
				local left = n - len(data)
				data = data .. sub(self.bufferRead, 1, left)
				self.bufferRead = sub(self.bufferRead, left + 1)
		until len(data) == n
		return data
end

function readLine(self, chop)
		local start = 1
		while true do
				local buf = self.bufferRead
				local i = buf:find("[\r\n]", start)
				local c = i and buf:sub(i,i)
				local is_cr = c == "\r"
				if i and (not is_cr or i < #buf) then
						local n = buf:sub(i+1,i+1)
						if is_cr and n == "\n" then
								c = c .. n
						end
						local result = buf:sub(1, i - 1) .. (chop and "" or c)
						self.bufferRead = buf:sub(i + #c)
						return result
				else
						start = #self.bufferRead - (is_cr and 1 or 0)
						local result, reason = readChunk(self)
						if not result then
								if reason then
										return nil, reason
								else
										result = #self.bufferRead > 0 and self.bufferRead or nil
										self.bufferRead = ""
										return result
								end
						end
				end
		end
end

function readAll(self)
		repeat
				local result, reason = readChunk(self)
				if not result and reason then
						return nil, reason
				end
		until not result
		local result = self.bufferRead
		self.bufferRead = ""
		return result
end

function bufferMethods:read(...)
		if not self.r then
				return nil, "read mode was not enabled for this stream"
		end
		if self.w or self.a then
				bufferMethods.flush(self)
		end
		local function read(i, arg)
				checkArg(i, arg, "number", "string")
				if type(arg) == "number" then
						return readBytesOrChars(self, arg)
				else
						local rt = unicode.sub(arg, 1, 1) == "*" and unicode.sub(arg, 2) or arg
						--[[if rt == "n" then
								return readNumber(self)
						else]]if rt == "l" then
								return readLine(self, true)
						elseif rt == "L" then
								return readLine(self, false)
						elseif rt == "a" then
								return readAll(self)
						else
								error("bad argument #" .. i .. " (n, l, L or a expected, got " .. arg .. ")")
						end
				end
		end
		local args = table.pack(...)
		if #args > 0 then
				local results = {}
				for i = 1, #args do
						local result, reason = read(i, args[i])
						if result then
								results[i] = result
						elseif reason then
								return nil, reason
						end
				end
				return table.unpack(results)
		else
				return readLine(self, true)
		end
end

function bufferMethods:write(...)
		if self.closed then
				return nil, "bad file descriptor"
		end
		if not self.w and not self.a then
				return nil, "write mode was not enabled for this stream"
		end
		local args = table.pack(...)
		for i = 1, #args do
				if type(args[i]) == "number" then
						args[i] = tostring(args[i])
				end
				checkArg(i, args[i], "string")
		end
		for i = 1, #args do
				local arg = args[i]
				local result, reason
				if self.bufferMode == "no" then
						result, reason = self.stream:write(arg)
				elseif self.bufferMode == "full" then
						if self.bufferSize - #self.bufferWrite < #arg then
								result, reason = bufferMethods.flush(self)
								if not result then
										return nil, reason
								end
						end
						if #arg > self.bufferSize then
								result, reason = self.stream:write(arg)
						else
								self.bufferWrite = self.bufferWrite .. arg
								result = self
						end
				else
						local l
						repeat
								local idx = arg:find("\n", (l or 0) + 1, true)
								if idx then
										l = idx
								end
						until not idx
						if l or #arg > self.bufferSize then
								result, reason = bufferMethods.flush(self)
								if not result then
										return nil, reason
								end
						end
						if l then
								result, reason = self.stream:write(arg:sub(1, l))
								if not result then
										return nil, reason
								end
								arg = arg:sub(l + 1)
						end
						if #arg > self.bufferSize then
								result, reason = self.stream:write(arg)
						else
								self.bufferWrite = self.bufferWrite .. arg
								result = self
						end
				end
		end
		if not result then
				return nil, reason
		end
		return true
end

function bufferMethods:setvbuf(mode, size)
		mode = mode or self.bufferMode
		size = size or self.bufferSize
		assert(mode == "no" or mode == "full" or mode == "line", "bad argument #1 (no, full or line expected, got " .. tostring(mode) .. ")")
		assert(mode == "no" or type(size) == "number", "bad argument #2 (number expected, got " .. type(size) .. ")")
		self.bufferMode = mode
		self.bufferSize = size
		return self.bufferMode, self.bufferSize
end

function bufferMethods:size()
		local len = self.b and rawlen or unicode.len
		local size = len(self.bufferRead)
		if self.stream.size then
				size = size + self.stream:size()
		end
		return size
end

function buffer(stream, mode)
		checkArg(1, stream, "table")
		checkArg(2, mode, "string", "nil")
		mode = mode or "r"
		local obj = {
				stream = stream,
				closed = false,
				bufferSize = 2048,
				bufferRead = "",
				bufferWrite = "",
				bufferMode = "full"
		}
		for i = 1, unicode.len(mode) do
				local m = unicode.sub(mode, i, i)
				assert(m == "r" or m == "w" or m == "a" or m == "b", "bad argument #2 (r, w, a, b expected got " .. m .. ")")
				obj[m] = true
		end
		return protectObject(obj, bufferMethods, "Stream")
end

local libbuffer = buffer

libs.buffer = libbuffer
;

libevent = {}

function libevent.on(event, f)
	local thread = createThread(function ()
		while true do
			f(table.unpack(table.pack(waitEvent("signal", event)), 2))
		end
	end, "[event listener]", thisThread.process)
end

-- TODO make event regexp
function libevent.wait(event, ...)
	return table.unpack(table.pack(waitEvent("signal", event, ...)), 2)
end

libs.event = libevent
;

local user = {}
local users = {
	[0] = {
		id = 0,
		login = "root",
		password = "toor",
		shell = "/bin/sh.lua"
	},
	[1000] = {
		id = 1000,
		login = "zabqer",
		password = "tester",
		shell = "/bin/sh.lua"
	}
}

function user.auth(login, password)
	local id
	for _, u in pairs(users) do
		if u.login == login then
			if u.password == password then
				return u.id
			else
				os.sleep(5)
			end
		end
	end
	return nil, "login incorrect"
end

function user.getInfo(id)
	if not users[id] then
		return nil, "no such user"
	end
	return protectTable({
		id = users[id].id,
		login = users[id].login,
		shell = users[id].shell
	}, true, false)
end

function processMethods:setUser(id)
	if self.process.user ~= "root" then
		return false, "permissions denied"
	end
	if not users[id] then
		return nil, "no such user"
        end
	self.process.user = users[id].login
	return true
end


libs.user = user
;

GLOBAL.io = {}

function GLOBAL.io.close(file)
		return (file or io.output()):close()
end

function GLOBAL.io.flush()
		return io.output():flush()
end

function GLOBAL.io.open(path, mode)
		local stream, reason = filesystem.open(path, mode)
		if stream then
				return buffer(stream, mode)
		else
				return nil, reason
		end
end

local pipeInputMethods, pipeOutputMethods = {}, {}

function pipeInputMethods:write(data)
		if self.closed then
				return false
		end
		local notify = #self.buffer == 0 and #data ~= 0
		self.buffer = self.buffer .. data
		if notify then
				pushEvent("pipe_changed", self, "append")
		end
		return true
end

function pipeInputMethods:close()
		if self.closed then
				return false
		end
		self.closed = true
		pushEvent("pipe_changed", self, "input_closed")
		return true
end

function pipeOutputMethods:read(count)
		if not self.buffer or #self.buffer == 0 and self.closed then
				return nil
		end
		if #self.buffer > 0 then
				local data = self.buffer:sub(1, count)
				self.buffer = self.buffer:sub(count + 1)
				return data
		end
		local _, _, t = waitEvent("pipe_changed", self)
		if t == "output_closed" then
				return nil
		elseif t == "append" then
				local data = self.buffer:sub(1, count)
				self.buffer = self.buffer:sub(count + 1)
				return data 
		end
end

function pipeOutputMethods:close()
		if not self.buffer then
				return false
		end
		self.buffer = nil
		pushEvent("pipe_changed", self, "output_closed")
		return true
end

function GLOBAL.io.pipe()
		local pipe = {
				buffer = "",
				closed = false
		}
		local wb = buffer(protectObject(pipe, pipeInputMethods, "PipeInput"), "w")
		wb:setvbuf("no")
		return wb, buffer(protectObject(pipe, pipeOutputMethods, "PipeOutput"), "r")
end

function GLOBAL.io.input(file)
		if file then
				if type(file) == "string" then
						local result, reason = io.open(file, "r")
						if not result then
								error(reason, 2)
						end
						file = result
				elseif not io.type(file) then
						error("bad argument #1 (string or file expected, got " .. type(file) .. ")", 2)
				end
				thisThread.process.stdin = file
		end
		return thisThread.process.stdin
end

function GLOBAL.io.read(...)
		return io.input():read(...)
end

function GLOBAL.io.output(file)
		if file then
				if type(file) == "string" then
						local result, reason = io.open(file, "w")
						if not result then
								error(reason, 2)
						end
						file = result
				elseif not io.type(file) then
						error("bad argument #1 (string or file expected, got " .. type(file) .. ")", 2)
				end
				thisThread.process.stdout = file
		end
		return thisThread.process.stdout
end

function GLOBAL.io.write(...)
		return io.output():write(...)
end

function io.error(file)
		if file then
				if type(file) == "string" then
						local result, reason = io.open(file, "w")
						if not result then
								error(reason, 2)
						end
						file = result
				elseif not io.type(file) then
						error("bad argument #1 (string or file expected, got " .. type(file) .. ")", 2)
				end
				thisThread.process.stderr = file
		end
		return thisThread.process.stderr
end

function GLOBAL.io.combine(mode, ...)
	-- TODO
	return select(2, ...)
end

local rewriterMethods = {}

function rewriterMethods:write(data)
	return self.stream:write(self.handler(data))
end

function GLOBAL.io.rewriter(f, stream)
	stream = buffer(protectObject({
		stream = stream,
		handler = f
	}, rewriterMethods, type(stream)), "w")
	stream:setvbuf("no")
	return stream
end


setmetatable(io, {__index = function (_, key)
		if key == "stdin" then
				return io.input()
		elseif key == "stdout" then
				return io.output()
		elseif key == "stderr" then
				return io.error()
		end
end})

ptss = {}

function GLOBAL.os.pts()
	-- TODO
	return {write=nullFunction, read=nullFunction}
end
;return (function(...)
		kernelLog(Log.DEBUG, "[main] Starting kernel")
		kernelLog(Log.INFO, "HyperKernel / " .. KernelVersion .. " / Zabqer")
		kernelLog(Log.INFO, "[main] Mounting root filesystem")
		success, reason = filesystem.mount("/", computer.getBootAddress())
		if not success then
			panic(reason)
		end
		filesystem.mount("/dev", devfs)
		kernelLog(Log.DEBUG, "[main] Spawning init thread")
		local init, reason = createProcess(function ()
				kernelLog(Log.DEBUG, "[init] Init started")
				dprint(loadfile("/sbin/init.lua"))
				local result, reason = pcall(loadfile(Config.initPath or "/sbin/init.lua"))
				panic("Init dead: " .. (reason or "unknown"))
		end, "init", _, "root")
		if not init then
			panic(reason)
		end
		init.workingDirectory = "/"
		init.stdout = kernelLogger
		init.stderr = kernelLogger
		kernelLog(Log.DEBUG, "[main] Starting thread handling loop")

		-- Move to threading???

		local lastYield = computer.uptime()
		yieldTime = 1--math.max(4.9, math.min(0.1, Config.yieldTime or 3))
		local function isTimeout()
			return computer.uptime() - lastYield > yieldTime
		end

		function resumeThread(thread, resumeArguments)
			kernelLog(Log.DEBUG, "Resume thread", thread.name, table.unpack(resumeArguments))
			thread.deadline = math.huge
			thread.running = true
			thisThread = thread
                        local result = table.pack(coroutine.resume(thread.coroutine, table.unpack(resumeArguments, 2)))
                        thisThread = kernelThread
			thread.running = false
			if not result[1] or coroutine.status(thread.coroutine) == "dead" then
                		kill(thread.pid)
				if result[2] then
					kernelLog(Log.ERROR, "Thread: [pid: " .. thread.pid .. "] died: " .. (result[2] or "unknown"))
				end
			else
				thread.awaiting = result[2]
				thread.awaitingArgs = table.pack(table.unpack(result, 3))
			end
		end

		function tryResume(thread)
			if not thread.paused then
 				for n, event in pairs(thread.eventQueue) do
					if event[1] == thread.awaiting then	
						table.remove(thread.eventQueue, n)
						resumeThread(thread, event)
						return
					end
				end
				if thread.deadline <= computer.uptime() then
					resumeThread(thread, {"deadline"})		
				end
			end
		end

		function nextDeadline()
			local deadline = math.huge
			for _, th in pairs(threads) do
				if not th.paused then
					if th.deadline < deadline then
						deadline = th.deadline
					end
				end
			end
			return deadline
		end

		local function countQueuedEvents(thread, t)
			local n, first = 0
			for i, event in pairs(thread.eventQueue) do
				if event[1] == t then
					n = n + 1
					if not first or first < i then
						first = i
					end
				end
			end
			return n, first
		end

		while true do
			while true do
				local resumed = false
				for _, thread in pairs(threads) do
					if tryResume(thread) then
						resumed = true
					end
					if isTimeout() then
						goto yieldMachine
					end
				end
				if not resumed then
					break
				end
			end
			::yieldMachine::
			local deadline = nextDeadline()
			-- TODO Call emitEvent or pushEvent
			local event = table.pack(computer.pullSignal(math.max(0, computer.uptime() - deadline)))
			lastYield = computer.uptime()
			if #event > 0 then
				for _, thread in pairs(threads) do
					local nevent, oldest = countQueuedEvents(thread, countQueuedEvents(thread, "signal"))
					if nevent >= 16 then
						table.remove(thread.eventQueue, oldest)
					end
					if event[2] then
						table.insert(thread.eventQueue, table.pack("signal", table.unpack(event)))
					end
				end
				for _, ehandler in pairs(eventHandlers) do
					for i, v in ipairs(ehandler.data) do
						if i ~= 1 and v ~= nil and v ~= event[i - 1] then
							goto continue
						end
					end
					ehandler.callback(table.unpack(event))
					::continue::
				end
			end

		end
end)(...)