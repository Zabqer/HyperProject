local fs = ...

local function help()
		print("build-kernel.lua [-v] <sources directory> [-o <kernel image>]")
end

local function error(message, code)
		print("Error: " .. message)
		os.exit(code or 1)
end

local verbose = print

local sourcesDirectory = "./src/"
local kernelPath = "kernel.lua"

local sources = {
		"src/allocator.lua",
		"src/driver_chatbox.lua",
		"src/component.lua",
		"src/log.lua",
		"src/config.lua",
		"src/io.lua",
		"src/utils.lua",
		"src/event.lua",
		"src/user.lua",
		"src/filesystem.lua",
		"src/dev_filesystem.lua",
		"src/threading.lua",
		--"src/userspace.lua",
		"src/buffer.lua",
		"src/main.lua"
}

local function readData(path)
		local handle = assert(io.open(path))
		local data = handle:read("a")
		handle:close()
		return data
end

local function writeData(path, data)
		local handle = assert(io.open(path, "w"))
		handle:write(data)
		handle:close()
end

verbose("> Collecting kernel modules")

local kernel, mainF = "--HyperKernel by Zabqer. This code is autogenerated by build-kernel utility\nlocal _K=setmetatable({},{__index=_G})_K.GLOBAL=_G;_ENV=_K;_K._K=_K;"

local modules = {}

for _, sourcePath in pairs(sources) do
		verbose("> > " .. sourcePath)
		local code = readData(sourcePath)
		local s, e = code:find("--%[%[.-%]%]--")
		if s == 1 then
				local module = {}
				local data = code:sub(s + 4, e - 4)
				code = code:sub(e + 2)
				local name = data:match("Name:%s([%w_]+);")
				if not name then
						error("Can't get name of module: " .. sourcePath)
				end
				module.description = data:match("Description:%s([%w_ ]+);")
				local deps = data:match("Depends:%s*%[([%w,%s]*)%];")
				if deps then
						module.dependicles = load("return{" .. deps:gsub("[%w_]+", "\"%1\"") .. "}")()
				end
				s, e = code:find("function main%(.-%).*end")
				if s then
						mainF = code:sub(s, e)
						code = code:sub(0, s - 1) .. code:sub(e + 1)
				end
				if name == "config" then
					code = code:gsub("rootfs = \"(.+)\"", "roofs=\""..fs.."\"")
				end
				module.code = code
				module.name = name
				modules[name] = module
		else
				error("Module header not found: " .. sourcePath)
		end
end

if not mainF then
		error("no main function found")
end

local code = {}

local handled = {}

local function handleModule(module)
		if not handled[module] then
				handled[module] = true
				if module.dependicles then
						for _, dep in ipairs(module.dependicles) do
								handleModule(modules[dep])
						end
				end
				verbose(">>> " .. module.name)
				table.insert(code, module.code)
		end
end

verbose("> Resolving dependicles")

for _, module in pairs(modules) do
		handleModule(module)
end

verbose("> Generating kernel code")

kernel = kernel .. table.concat(code, ";") .. ";" .. mainF:gsub("function main%((.-)%)(.*)end", "return (function(%1)%2end)(...)")

verbose("> Writing kernel image")

writeData(kernelPath, kernel)
